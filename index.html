<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="Asciidoctor 0.1.4">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Resolução dos exercícios de PDI</title>
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary { display: block; }
audio, canvas, video { display: inline-block; }
audio:not([controls]) { display: none; height: 0; }
[hidden] { display: none; }
html { background: #fff; color: #000; font-family: sans-serif; -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; }
body { margin: 0; }
a:focus { outline: thin dotted; }
a:active, a:hover { outline: 0; }
h1 { font-size: 2em; margin: 0.67em 0; }
abbr[title] { border-bottom: 1px dotted; }
b, strong { font-weight: bold; }
dfn { font-style: italic; }
hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; }
mark { background: #ff0; color: #000; }
code, kbd, pre, samp { font-family: monospace, serif; font-size: 1em; }
pre { white-space: pre-wrap; }
q { quotes: "\201C" "\201D" "\2018" "\2019"; }
small { font-size: 80%; }
sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }
sup { top: -0.5em; }
sub { bottom: -0.25em; }
img { border: 0; }
svg:not(:root) { overflow: hidden; }
figure { margin: 0; }
fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; }
legend { border: 0; padding: 0; }
button, input, select, textarea { font-family: inherit; font-size: 100%; margin: 0; }
button, input { line-height: normal; }
button, select { text-transform: none; }
button, html input[type="button"], input[type="reset"], input[type="submit"] { -webkit-appearance: button; cursor: pointer; }
button[disabled], html input[disabled] { cursor: default; }
input[type="checkbox"], input[type="radio"] { box-sizing: border-box; padding: 0; }
input[type="search"] { -webkit-appearance: textfield; -moz-box-sizing: content-box; -webkit-box-sizing: content-box; box-sizing: content-box; }
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration { -webkit-appearance: none; }
button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; }
textarea { overflow: auto; vertical-align: top; }
table { border-collapse: collapse; border-spacing: 0; }
*, *:before, *:after { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }
html, body { font-size: 100%; }
body { background: white; color: #222222; padding: 0; margin: 0; font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif; font-weight: normal; font-style: normal; line-height: 1; position: relative; cursor: auto; }
a:hover { cursor: pointer; }
a:focus { outline: none; }
img, object, embed { max-width: 100%; height: auto; }
object, embed { height: 100%; }
img { -ms-interpolation-mode: bicubic; }
#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object { max-width: none !important; }
.left { float: left !important; }
.right { float: right !important; }
.text-left { text-align: left !important; }
.text-right { text-align: right !important; }
.text-center { text-align: center !important; }
.text-justify { text-align: justify !important; }
.hide { display: none; }
.antialiased, body { -webkit-font-smoothing: antialiased; }
img { display: inline-block; vertical-align: middle; }
textarea { height: auto; min-height: 50px; }
select { width: 100%; }
p.lead, .paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { font-size: 1.21875em; line-height: 1.6; }
.subheader, #content #toctitle, .admonitionblock td.content > .title, .exampleblock > .title, .imageblock > .title, .videoblock > .title, .listingblock > .title, .literalblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, .sidebarblock > .title, .tableblock > .title, .verseblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title, .tableblock > caption { line-height: 1.4; color: #7a2518; font-weight: 300; margin-top: 0.2em; margin-bottom: 0.5em; }
div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td { margin: 0; padding: 0; direction: ltr; }
a { color: #005498; text-decoration: underline; line-height: inherit; }
a:hover, a:focus { color: #00467f; }
a img { border: none; }
p { font-family: inherit; font-weight: normal; font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; text-rendering: optimizeLegibility; }
p aside { font-size: 0.875em; line-height: 1.35; font-style: italic; }
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { font-family: Georgia, "URW Bookman L", Helvetica, Arial, sans-serif; font-weight: normal; font-style: normal; color: #ba3925; text-rendering: optimizeLegibility; margin-top: 1em; margin-bottom: 0.5em; line-height: 1.2125em; }
h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small { font-size: 60%; color: #e99b8f; line-height: 0; }
h1 { font-size: 2.125em; }
h2 { font-size: 1.6875em; }
h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.375em; }
h4 { font-size: 1.125em; }
h5 { font-size: 1.125em; }
h6 { font-size: 1em; }
hr { border: solid #dddddd; border-width: 1px 0 0; clear: both; margin: 1.25em 0 1.1875em; height: 0; }
em, i { font-style: italic; line-height: inherit; }
strong, b { font-weight: bold; line-height: inherit; }
small { font-size: 60%; line-height: inherit; }
code { font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: normal; color: #6d180b; }
ul, ol, dl { font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; list-style-position: outside; font-family: inherit; }
ul, ol { margin-left: 1.5em; }
ul li ul, ul li ol { margin-left: 1.25em; margin-bottom: 0; font-size: 1em; }
ul.square li ul, ul.circle li ul, ul.disc li ul { list-style: inherit; }
ul.square { list-style-type: square; }
ul.circle { list-style-type: circle; }
ul.disc { list-style-type: disc; }
ul.no-bullet { list-style: none; }
ol li ul, ol li ol { margin-left: 1.25em; margin-bottom: 0; }
dl dt { margin-bottom: 0.3125em; font-weight: bold; }
dl dd { margin-bottom: 1.25em; }
abbr, acronym { text-transform: uppercase; font-size: 90%; color: #222222; border-bottom: 1px dotted #dddddd; cursor: help; }
abbr { text-transform: none; }
blockquote { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
blockquote cite { display: block; font-size: inherit; color: #555555; }
blockquote cite:before { content: "\2014 \0020"; }
blockquote cite a, blockquote cite a:visited { color: #555555; }
blockquote, blockquote p { line-height: 1.6; color: #6f6f6f; }
.vcard { display: inline-block; margin: 0 0 1.25em 0; border: 1px solid #dddddd; padding: 0.625em 0.75em; }
.vcard li { margin: 0; display: block; }
.vcard .fn { font-weight: bold; font-size: 0.9375em; }
.vevent .summary { font-weight: bold; }
.vevent abbr { cursor: auto; text-decoration: none; font-weight: bold; border: none; padding: 0 0.0625em; }
@media only screen and (min-width: 768px) { h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.4; }
  h1 { font-size: 2.75em; }
  h2 { font-size: 2.3125em; }
  h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.6875em; }
  h4 { font-size: 1.4375em; } }
.print-only { display: none !important; }
@media print { * { background: transparent !important; color: #000 !important; box-shadow: none !important; text-shadow: none !important; }
  a, a:visited { text-decoration: underline; }
  a[href]:after { content: " (" attr(href) ")"; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after { content: ""; }
  pre, blockquote { border: 1px solid #999; page-break-inside: avoid; }
  thead { display: table-header-group; }
  tr, img { page-break-inside: avoid; }
  img { max-width: 100% !important; }
  @page { margin: 0.5cm; }
  p, h2, h3, #toctitle, .sidebarblock > .content > .title { orphans: 3; widows: 3; }
  h2, h3, #toctitle, .sidebarblock > .content > .title { page-break-after: avoid; }
  .hide-on-print { display: none !important; }
  .print-only { display: block !important; }
  .hide-for-print { display: none !important; }
  .show-for-print { display: inherit !important; } }
table { background: white; margin-bottom: 1.25em; border: solid 1px #dddddd; }
table thead, table tfoot { background: whitesmoke; font-weight: bold; }
table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td { padding: 0.5em 0.625em 0.625em; font-size: inherit; color: #222222; text-align: left; }
table tr th, table tr td { padding: 0.5625em 0.625em; font-size: inherit; color: #222222; }
table tr.even, table tr.alt, table tr:nth-of-type(even) { background: #f9f9f9; }
table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td { display: table-cell; line-height: 1.6; }
.clearfix:before, .clearfix:after, .float-group:before, .float-group:after { content: " "; display: table; }
.clearfix:after, .float-group:after { clear: both; }
*:not(pre) > code { font-size: 0.9375em; padding: 1px 3px 0; white-space: nowrap; background-color: #f2f2f2; border: 1px solid #cccccc; -webkit-border-radius: 4px; border-radius: 4px; text-shadow: none; }
pre, pre > code { line-height: 1.4; color: inherit; font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: normal; }
kbd.keyseq { color: #555555; }
kbd:not(.keyseq) { display: inline-block; color: #222222; font-size: 0.75em; line-height: 1.4; background-color: #F7F7F7; border: 1px solid #ccc; -webkit-border-radius: 3px; border-radius: 3px; -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset; box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset; margin: -0.15em 0.15em 0 0.15em; padding: 0.2em 0.6em 0.2em 0.5em; vertical-align: middle; white-space: nowrap; }
kbd kbd:first-child { margin-left: 0; }
kbd kbd:last-child { margin-right: 0; }
.menuseq, .menu { color: #090909; }
p a > code:hover { color: #561309; }
#header, #content, #footnotes, #footer { width: 100%; margin-left: auto; margin-right: auto; margin-top: 0; margin-bottom: 0; max-width: 62.5em; *zoom: 1; position: relative; padding-left: 0.9375em; padding-right: 0.9375em; }
#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after { content: " "; display: table; }
#header:after, #content:after, #footnotes:after, #footer:after { clear: both; }
#header { margin-bottom: 2.5em; }
#header > h1 { color: black; font-weight: normal; border-bottom: 1px solid #dddddd; margin-bottom: -28px; padding-bottom: 32px; }
#header span { color: #6f6f6f; }
#header #revnumber { text-transform: capitalize; }
#header br { display: none; }
#header br + span { padding-left: 3px; }
#header br + span:before { content: "\2013 \0020"; }
#header br + span.author { padding-left: 0; }
#header br + span.author:before { content: ", "; }
#toc { border-bottom: 3px double #ebebeb; padding-bottom: 1.25em; }
#toc > ul { margin-left: 0.25em; }
#toc ul.sectlevel0 > li > a { font-style: italic; }
#toc ul.sectlevel0 ul.sectlevel1 { margin-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
#toc ul { list-style-type: none; }
#toctitle { color: #7a2518; }
@media only screen and (min-width: 1280px) { body.toc2 { padding-left: 20em; }
  #toc.toc2 { position: fixed; width: 20em; left: 0; top: 0; border-right: 1px solid #ebebeb; border-bottom: 0; z-index: 1000; padding: 1em; height: 100%; overflow: auto; }
  #toc.toc2 #toctitle { margin-top: 0; }
  #toc.toc2 > ul { font-size: .95em; }
  #toc.toc2 ul ul { margin-left: 0; padding-left: 1.25em; }
  #toc.toc2 ul.sectlevel0 ul.sectlevel1 { padding-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 20em; }
  body.toc2.toc-right #toc.toc2 { border-right: 0; border-left: 1px solid #ebebeb; left: auto; right: 0; } }
#content #toc { border-style: solid; border-width: 1px; border-color: #d9d9d9; margin-bottom: 1.25em; padding: 1.25em; background: #f2f2f2; border-width: 0; -webkit-border-radius: 4px; border-radius: 4px; }
#content #toc > :first-child { margin-top: 0; }
#content #toc > :last-child { margin-bottom: 0; }
#content #toc a { text-decoration: none; }
#content #toctitle { font-weight: bold; font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif; font-size: 1em; padding-left: 0.125em; }
#footer { max-width: 100%; background-color: #222222; padding: 1.25em; }
#footer-text { color: #dddddd; line-height: 1.44; }
.sect1 { padding-bottom: 1.25em; }
.sect1 + .sect1 { border-top: 3px double #ebebeb; }
#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor { position: absolute; width: 1em; margin-left: -1em; display: block; text-decoration: none; visibility: hidden; text-align: center; font-weight: normal; }
#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before { content: '\00A7'; font-size: .85em; vertical-align: text-top; display: block; margin-top: 0.05em; }
#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover { visibility: visible; }
#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link { color: #ba3925; text-decoration: none; }
#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover { color: #a53221; }
.imageblock, .literalblock, .listingblock, .verseblock, .videoblock { margin-bottom: 1.25em; }
.admonitionblock td.content > .title, .exampleblock > .title, .imageblock > .title, .videoblock > .title, .listingblock > .title, .literalblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, .sidebarblock > .title, .tableblock > .title, .verseblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { text-align: left; font-weight: bold; }
.tableblock > caption { text-align: left; font-weight: bold; white-space: nowrap; overflow: visible; max-width: 0; }
table.tableblock #preamble > .sectionbody > .paragraph:first-of-type p { font-size: inherit; }
.admonitionblock > table { border: 0; background: none; width: 100%; }
.admonitionblock > table td.icon { text-align: center; width: 80px; }
.admonitionblock > table td.icon img { max-width: none; }
.admonitionblock > table td.icon .title { font-weight: bold; text-transform: uppercase; }
.admonitionblock > table td.content { padding-left: 1.125em; padding-right: 1.25em; border-left: 1px solid #dddddd; color: #6f6f6f; }
.admonitionblock > table td.content > :last-child > :last-child { margin-bottom: 0; }
.exampleblock > .content { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: white; -webkit-border-radius: 4px; border-radius: 4px; }
.exampleblock > .content > :first-child { margin-top: 0; }
.exampleblock > .content > :last-child { margin-bottom: 0; }
.exampleblock > .content h1, .exampleblock > .content h2, .exampleblock > .content h3, .exampleblock > .content #toctitle, .sidebarblock.exampleblock > .content > .title, .exampleblock > .content h4, .exampleblock > .content h5, .exampleblock > .content h6, .exampleblock > .content p { color: #333333; }
.exampleblock > .content h1, .exampleblock > .content h2, .exampleblock > .content h3, .exampleblock > .content #toctitle, .sidebarblock.exampleblock > .content > .title, .exampleblock > .content h4, .exampleblock > .content h5, .exampleblock > .content h6 { line-height: 1; margin-bottom: 0.625em; }
.exampleblock > .content h1.subheader, .exampleblock > .content h2.subheader, .exampleblock > .content h3.subheader, .exampleblock > .content .subheader#toctitle, .sidebarblock.exampleblock > .content > .subheader.title, .exampleblock > .content h4.subheader, .exampleblock > .content h5.subheader, .exampleblock > .content h6.subheader { line-height: 1.4; }
.exampleblock.result > .content { -webkit-box-shadow: 0 1px 8px #d9d9d9; box-shadow: 0 1px 8px #d9d9d9; }
.sidebarblock { border-style: solid; border-width: 1px; border-color: #d9d9d9; margin-bottom: 1.25em; padding: 1.25em; background: #f2f2f2; -webkit-border-radius: 4px; border-radius: 4px; }
.sidebarblock > :first-child { margin-top: 0; }
.sidebarblock > :last-child { margin-bottom: 0; }
.sidebarblock h1, .sidebarblock h2, .sidebarblock h3, .sidebarblock #toctitle, .sidebarblock > .content > .title, .sidebarblock h4, .sidebarblock h5, .sidebarblock h6, .sidebarblock p { color: #333333; }
.sidebarblock h1, .sidebarblock h2, .sidebarblock h3, .sidebarblock #toctitle, .sidebarblock > .content > .title, .sidebarblock h4, .sidebarblock h5, .sidebarblock h6 { line-height: 1; margin-bottom: 0.625em; }
.sidebarblock h1.subheader, .sidebarblock h2.subheader, .sidebarblock h3.subheader, .sidebarblock .subheader#toctitle, .sidebarblock > .content > .subheader.title, .sidebarblock h4.subheader, .sidebarblock h5.subheader, .sidebarblock h6.subheader { line-height: 1.4; }
.sidebarblock > .content > .title { color: #7a2518; margin-top: 0; line-height: 1.6; }
.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child { margin-bottom: 0; }
.literalblock > .content pre, .listingblock > .content pre { background: none; border-width: 1px 0; border-style: dotted; border-color: #bfbfbf; -webkit-border-radius: 4px; border-radius: 4px; padding: 0.75em 0.75em 0.5em 0.75em; word-wrap: break-word; }
.literalblock > .content pre.nowrap, .listingblock > .content pre.nowrap { overflow-x: auto; white-space: pre; word-wrap: normal; }
.literalblock > .content pre > code, .listingblock > .content pre > code { display: block; }
@media only screen { .literalblock > .content pre, .listingblock > .content pre { font-size: 0.8em; } }
@media only screen and (min-width: 768px) { .literalblock > .content pre, .listingblock > .content pre { font-size: 0.9em; } }
@media only screen and (min-width: 1280px) { .literalblock > .content pre, .listingblock > .content pre { font-size: 1em; } }
.listingblock > .content { position: relative; }
.listingblock:hover code[class*=" language-"]:before { text-transform: uppercase; font-size: 0.9em; color: #999; position: absolute; top: 0.375em; right: 0.375em; }
.listingblock:hover code.asciidoc:before { content: "asciidoc"; }
.listingblock:hover code.clojure:before { content: "clojure"; }
.listingblock:hover code.css:before { content: "css"; }
.listingblock:hover code.groovy:before { content: "groovy"; }
.listingblock:hover code.html:before { content: "html"; }
.listingblock:hover code.java:before { content: "java"; }
.listingblock:hover code.javascript:before { content: "javascript"; }
.listingblock:hover code.python:before { content: "python"; }
.listingblock:hover code.ruby:before { content: "ruby"; }
.listingblock:hover code.scss:before { content: "scss"; }
.listingblock:hover code.xml:before { content: "xml"; }
.listingblock:hover code.yaml:before { content: "yaml"; }
.listingblock.terminal pre .command:before { content: attr(data-prompt); padding-right: 0.5em; color: #999; }
.listingblock.terminal pre .command:not([data-prompt]):before { content: '$'; }
table.pyhltable { border: 0; margin-bottom: 0; }
table.pyhltable td { vertical-align: top; padding-top: 0; padding-bottom: 0; }
table.pyhltable td.code { padding-left: .75em; padding-right: 0; }
.highlight.pygments .lineno, table.pyhltable td:not(.code) { color: #999; padding-left: 0; padding-right: .5em; border-right: 1px solid #dddddd; }
.highlight.pygments .lineno { display: inline-block; margin-right: .25em; }
table.pyhltable .linenodiv { background-color: transparent !important; padding-right: 0 !important; }
.quoteblock { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
.quoteblock blockquote { margin: 0 0 1.25em 0; padding: 0 0 0.5625em 0; border: 0; }
.quoteblock blockquote > .paragraph:last-child p { margin-bottom: 0; }
.quoteblock .attribution { margin-top: -.25em; padding-bottom: 0.5625em; font-size: inherit; color: #555555; }
.quoteblock .attribution br { display: none; }
.quoteblock .attribution cite { display: block; margin-bottom: 0.625em; }
table thead th, table tfoot th { font-weight: bold; }
table.tableblock.grid-all { border-collapse: separate; border-spacing: 1px; -webkit-border-radius: 4px; border-radius: 4px; border-top: 1px solid #dddddd; border-bottom: 1px solid #dddddd; }
table.tableblock.frame-topbot, table.tableblock.frame-none { border-left: 0; border-right: 0; }
table.tableblock.frame-sides, table.tableblock.frame-none { border-top: 0; border-bottom: 0; }
table.tableblock td .paragraph:last-child p, table.tableblock td > p:last-child { margin-bottom: 0; }
th.tableblock.halign-left, td.tableblock.halign-left { text-align: left; }
th.tableblock.halign-right, td.tableblock.halign-right { text-align: right; }
th.tableblock.halign-center, td.tableblock.halign-center { text-align: center; }
th.tableblock.valign-top, td.tableblock.valign-top { vertical-align: top; }
th.tableblock.valign-bottom, td.tableblock.valign-bottom { vertical-align: bottom; }
th.tableblock.valign-middle, td.tableblock.valign-middle { vertical-align: middle; }
p.tableblock.header { color: #222222; font-weight: bold; }
td > div.verse { white-space: pre; }
ol { margin-left: 1.75em; }
ul li ol { margin-left: 1.5em; }
dl dd { margin-left: 1.125em; }
dl dd:last-child, dl dd:last-child > :last-child { margin-bottom: 0; }
ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist { margin-bottom: 0.625em; }
ul.unstyled, ol.unnumbered, ul.checklist, ul.none { list-style-type: none; }
ul.unstyled, ol.unnumbered, ul.checklist { margin-left: 0.625em; }
ul.checklist li > p:first-child > i[class^="icon-check"]:first-child, ul.checklist li > p:first-child > input[type="checkbox"]:first-child { margin-right: 0.25em; }
ul.checklist li > p:first-child > input[type="checkbox"]:first-child { position: relative; top: 1px; }
ul.inline { margin: 0 auto 0.625em auto; margin-left: -1.375em; margin-right: 0; padding: 0; list-style: none; overflow: hidden; }
ul.inline > li { list-style: none; float: left; margin-left: 1.375em; display: block; }
ul.inline > li > * { display: block; }
.unstyled dl dt { font-weight: normal; font-style: normal; }
ol.arabic { list-style-type: decimal; }
ol.decimal { list-style-type: decimal-leading-zero; }
ol.loweralpha { list-style-type: lower-alpha; }
ol.upperalpha { list-style-type: upper-alpha; }
ol.lowerroman { list-style-type: lower-roman; }
ol.upperroman { list-style-type: upper-roman; }
ol.lowergreek { list-style-type: lower-greek; }
.hdlist > table, .colist > table { border: 0; background: none; }
.hdlist > table > tbody > tr, .colist > table > tbody > tr { background: none; }
td.hdlist1 { padding-right: .8em; font-weight: bold; }
td.hdlist1, td.hdlist2 { vertical-align: top; }
.literalblock + .colist, .listingblock + .colist { margin-top: -0.5em; }
.colist > table tr > td:first-of-type { padding: 0 .8em; line-height: 1; }
.colist > table tr > td:last-of-type { padding: 0.25em 0; }
.qanda > ol > li > p > em:only-child { color: #00467f; }
.thumb, .th { line-height: 0; display: inline-block; border: solid 4px white; -webkit-box-shadow: 0 0 0 1px #dddddd; box-shadow: 0 0 0 1px #dddddd; }
.imageblock.left, .imageblock[style*="float: left"] { margin: 0.25em 0.625em 1.25em 0; }
.imageblock.right, .imageblock[style*="float: right"] { margin: 0.25em 0 1.25em 0.625em; }
.imageblock > .title { margin-bottom: 0; }
.imageblock.thumb, .imageblock.th { border-width: 6px; }
.imageblock.thumb > .title, .imageblock.th > .title { padding: 0 0.125em; }
.image.left, .image.right { margin-top: 0.25em; margin-bottom: 0.25em; display: inline-block; line-height: 0; }
.image.left { margin-right: 0.625em; }
.image.right { margin-left: 0.625em; }
a.image { text-decoration: none; }
span.footnote, span.footnoteref { vertical-align: super; font-size: 0.875em; }
span.footnote a, span.footnoteref a { text-decoration: none; }
#footnotes { padding-top: 0.75em; padding-bottom: 0.75em; margin-bottom: 0.625em; }
#footnotes hr { width: 20%; min-width: 6.25em; margin: -.25em 0 .75em 0; border-width: 1px 0 0 0; }
#footnotes .footnote { padding: 0 0.375em; line-height: 1.3; font-size: 0.875em; margin-left: 1.2em; text-indent: -1.2em; margin-bottom: .2em; }
#footnotes .footnote a:first-of-type { font-weight: bold; text-decoration: none; }
#footnotes .footnote:last-of-type { margin-bottom: 0; }
#content #footnotes { margin-top: -0.625em; margin-bottom: 0; padding: 0.75em 0; }
.gist .file-data > table { border: none; background: #fff; width: 100%; margin-bottom: 0; }
.gist .file-data > table td.line-data { width: 99%; }
div.unbreakable { page-break-inside: avoid; }
.big { font-size: larger; }
.small { font-size: smaller; }
.underline { text-decoration: underline; }
.overline { text-decoration: overline; }
.line-through { text-decoration: line-through; }
.aqua { color: #00bfbf; }
.aqua-background { background-color: #00fafa; }
.black { color: black; }
.black-background { background-color: black; }
.blue { color: #0000bf; }
.blue-background { background-color: #0000fa; }
.fuchsia { color: #bf00bf; }
.fuchsia-background { background-color: #fa00fa; }
.gray { color: #606060; }
.gray-background { background-color: #7d7d7d; }
.green { color: #006000; }
.green-background { background-color: #007d00; }
.lime { color: #00bf00; }
.lime-background { background-color: #00fa00; }
.maroon { color: #600000; }
.maroon-background { background-color: #7d0000; }
.navy { color: #000060; }
.navy-background { background-color: #00007d; }
.olive { color: #606000; }
.olive-background { background-color: #7d7d00; }
.purple { color: #600060; }
.purple-background { background-color: #7d007d; }
.red { color: #bf0000; }
.red-background { background-color: #fa0000; }
.silver { color: #909090; }
.silver-background { background-color: #bcbcbc; }
.teal { color: #006060; }
.teal-background { background-color: #007d7d; }
.white { color: #bfbfbf; }
.white-background { background-color: #fafafa; }
.yellow { color: #bfbf00; }
.yellow-background { background-color: #fafa00; }
span.icon > [class^="icon-"], span.icon > [class*=" icon-"] { cursor: default; }
.admonitionblock td.icon [class^="icon-"]:before { font-size: 2.5em; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); cursor: default; }
.admonitionblock td.icon .icon-note:before { content: "\f05a"; color: #005498; color: #003f72; }
.admonitionblock td.icon .icon-tip:before { content: "\f0eb"; text-shadow: 1px 1px 2px rgba(155, 155, 0, 0.8); color: #111; }
.admonitionblock td.icon .icon-warning:before { content: "\f071"; color: #bf6900; }
.admonitionblock td.icon .icon-caution:before { content: "\f06d"; color: #bf3400; }
.admonitionblock td.icon .icon-important:before { content: "\f06a"; color: #bf0000; }
.conum { display: inline-block; color: white !important; background-color: #222222; -webkit-border-radius: 100px; border-radius: 100px; text-align: center; width: 20px; height: 20px; font-size: 12px; font-weight: bold; line-height: 20px; font-family: Arial, sans-serif; font-style: normal; position: relative; top: -2px; letter-spacing: -1px; }
.conum * { color: white !important; }
.conum + b { display: none; }
.conum:after { content: attr(data-value); }
.conum:not([data-value]):empty { display: none; }
.literalblock > .content > pre, .listingblock > .content > pre { -webkit-border-radius: 0; border-radius: 0; }

</style>
<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="http://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>document.addEventListener('DOMContentLoaded', prettyPrint)</script>
</head>
<body class="article toc2 toc-right">
<div id="header">
<h1>Resolução dos exercícios de PDI</h1>
<span id="author" class="author">Marcella Barros de Brito Cavalcanti</span><br>
<span id="email" class="email"><a href="mailto:marcellabcavalcanti@gmail.com">marcellabcavalcanti@gmail.com</a></span><br>
<div id="toc" class="toc2">
<div id="toctitle">Conteúdo</div>
<ul class="sectlevel1">
<li><a href="#_1_se_o_3_manipulando_pixels_em_uma_imagem">1. Seção 3: Manipulando pixels em uma imagem</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#_1_1_exerc_cio_1">1.1 Exercício 1</a></li>
<li><a href="#_1_2_exerc_cio_2">1.2 Exercício 2</a></li>
</ul>
</li>
<li><a href="#_2_se_o_4_preenchendo_regi_es">2. Seção 4: Preenchendo regiões</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#_2_1_exerc_cio_1">2.1 Exercício 1</a></li>
<li><a href="#_2_2_exerc_cio_2">2.2 Exercício 2</a></li>
</ul>
</li>
<li><a href="#_3_se_o_6_filtragem_no_dom_nio_espacial_i">3. Seção 6: Filtragem no domínio espacial I</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#_3_1_exerc_cio">3.1 Exercício</a></li>
</ul>
</li>
<li><a href="#_4_se_o_7_filtragem_no_dom_nio_espacial_ii">4. Seção 7: Filtragem no domínio espacial II</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#_4_1_exerc_cio_1">4.1 Exercício 1</a></li>
</ul>
</li>
<li><a href="#_5_se_o_8_filtragem_no_dom_nio_da_frequ_ncia">5. Seção 8: Filtragem no domínio da frequência</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#_5_1_exerc_cio">5.1 Exercício</a></li>
</ul>
</li>
<li><a href="#_6_se_o_10_canny_e_a_arte_com_pontilhismo">6. Seção 10: Canny e a arte com pontilhismo</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#_6_1_exerc_cio">6.1 Exercício</a></li>
</ul>
</li>
<li><a href="#_bibliografia">Bibliografia</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_1_se_o_3_manipulando_pixels_em_uma_imagem">1. Seção 3: Manipulando pixels em uma imagem</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_1_1_exerc_cio_1">1.1 Exercício 1</h3>
<div class="paragraph">
<p>Implementar um programa <code>regions.cpp</code>, que solicite ao usuário coordenadas de dois pontos <em>P<sub>1</sub></em> e <em>P<sub>2</sub></em> e exiba o retângulo delimitado por eles como o negativo da imagem original.</p>
</div>
<div class="sect3">
<h4 id="_c_digo">Código</h4>
<div class="sidebarblock">
<div class="content">
<div class="listingblock">
<div class="title">regions.cpp</div>
<div class="content">
<pre class="prettyprint c++ language-c++"><code>#include &lt;iostream&gt;
#include &lt;cv.h&gt;
#include &lt;highgui.h&gt;

using namespace cv;
using namespace std;

int main(int, char**){
  Mat image;

  int width, height;
  Vec4i pontos; //vetor para os pontos P1 e P2

  int x;

  image= imread("biel.png",CV_LOAD_IMAGE_GRAYSCALE);
  if(!image.data)
    cout &lt;&lt; "nao abriu biel.png" &lt;&lt; endl;

//pega o tamanho da imagem, em pixels
  width=image.size().width;
  height=image.size().height;

  namedWindow("janela",WINDOW_AUTOSIZE);

  cout &lt;&lt; "Escolha dois pontos (x,y) da imagem, levando em consideração que a imagem é de tamanho " &lt;&lt; width &lt;&lt; "x" &lt;&lt; height &lt;&lt; "." &lt;&lt; endl;

  cout &lt;&lt; "Ponto P1:" &lt;&lt; endl &lt;&lt; "x = ";
  cin &gt;&gt; pontos[0];
  cout &lt;&lt; "y = ";
  cin &gt;&gt; pontos[1];

  cout &lt;&lt; "Ponto P2:" &lt;&lt; endl &lt;&lt; "x = ";
  cin &gt;&gt; pontos[2];
  cout &lt;&lt; "y = ";
  cin &gt;&gt; pontos[3];

//condições de "tamanho" das coordenadas, para que o loops funcionem

  if((pontos[2]&gt;pontos[0])&amp;(pontos[3]&gt;pontos[1])){
	  for(int i=pontos[0];i&lt;pontos[2];i++){
	    for(int j=pontos[1];j&lt;pontos[3];j++){
	      x = image.at&lt;uchar&gt;(i,j); //pega a cor atual do pixel em (i,j)
	      image.at&lt;uchar&gt;(i,j)= 255 - x; //negativo
	    }
	  }
  } else if((pontos[0]&gt;pontos[2])&amp;(pontos[3]&gt;pontos[1])){
	  for(int i=pontos[2];i&lt;pontos[0];i++){
	    for(int j=pontos[1];j&lt;pontos[3];j++){
	      x = image.at&lt;uchar&gt;(i,j);
	      image.at&lt;uchar&gt;(i,j)= 255 - x;
	    }
	  }
  } else if((pontos[2]&gt;pontos[0])&amp;(pontos[1]&gt;pontos[3])){
	  for(int i=pontos[0];i&lt;pontos[2];i++){
	    for(int j=pontos[3];j&lt;pontos[1];j++){
	      x = image.at&lt;uchar&gt;(i,j);
	      image.at&lt;uchar&gt;(i,j)= 255 - x;
	    }
	  }
  } else {
  	for(int i=pontos[2];i&lt;pontos[0];i++){
	    for(int j=pontos[3];j&lt;pontos[1];j++){
	      x = image.at&lt;uchar&gt;(i,j);
	      image.at&lt;uchar&gt;(i,j)= 255 - x;
	    }
	  }
  }
  imshow("janela", image);
  waitKey();

  return 0;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>A execução e saída do programa <em>regions</em>, para os pontos escolhidos <em>P<sub>1</sub></em>=(100, 250) e <em>P<sub>2</sub></em>=(30, 20), são mostradas nas figuras abaixo:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://raw.githubusercontent.com/marcellacavalcanti/PDI/master/regions_exe.png" alt="regions_exe"></span></p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://raw.githubusercontent.com/marcellacavalcanti/PDI/master/regions_.png" alt="regions_"></span></p>
</div>
</div>
<div class="sect3">
<h4 id="_descri_o_do_c_digo">Descrição do código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint c++ language-c++"><code>//pega o tamanho da imagem, em pixels
  width=image.size().width;
  height=image.size().height;

  namedWindow("janela",WINDOW_AUTOSIZE);

  cout &lt;&lt; "Escolha dois pontos (x,y) da imagem, levando em consideração que a imagem é de tamanho " &lt;&lt; width &lt;&lt; "x" &lt;&lt; height &lt;&lt; "." &lt;&lt; endl;

  cout &lt;&lt; "Ponto P1:" &lt;&lt; endl &lt;&lt; "x = ";
  cin &gt;&gt; pontos[0];
  cout &lt;&lt; "y = ";
  cin &gt;&gt; pontos[1];

  cout &lt;&lt; "Ponto P2:" &lt;&lt; endl &lt;&lt; "x = ";
  cin &gt;&gt; pontos[2];
  cout &lt;&lt; "y = ";
  cin &gt;&gt; pontos[3];</code></pre>
</div>
</div>
<div class="paragraph">
<p>Após ler a imagem, pega-se altura e largura, para, então, informar ao usuário o tamanho da imagem e pedir que ele entre com as coordenadas de <em>P<sub>1</sub></em> e <em>P<sub>2</sub></em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint c++ language-c++"><code>//condições de "tamanho" das coordenadas, para que o loops funcionem

  if((pontos[2]&gt;pontos[0])&amp;(pontos[3]&gt;pontos[1])){
	  for(int i=pontos[0];i&lt;pontos[2];i++){
	    for(int j=pontos[1];j&lt;pontos[3];j++){
	      x = image.at&lt;uchar&gt;(i,j); //pega a cor atual do pixel em (i,j)
	      image.at&lt;uchar&gt;(i,j)= 255 - x; //negativo
	    }
	  }
  } else if((pontos[0]&gt;pontos[2])&amp;(pontos[3]&gt;pontos[1])){
	  for(int i=pontos[2];i&lt;pontos[0];i++){
	    for(int j=pontos[1];j&lt;pontos[3];j++){
	      x = image.at&lt;uchar&gt;(i,j);
	      image.at&lt;uchar&gt;(i,j)= 255 - x;
	    }
	  }
  } else if((pontos[2]&gt;pontos[0])&amp;(pontos[1]&gt;pontos[3])){
	  for(int i=pontos[0];i&lt;pontos[2];i++){
	    for(int j=pontos[3];j&lt;pontos[1];j++){
	      x = image.at&lt;uchar&gt;(i,j);
	      image.at&lt;uchar&gt;(i,j)= 255 - x;
	    }
	  }
  } else {
  	for(int i=pontos[2];i&lt;pontos[0];i++){
	    for(int j=pontos[3];j&lt;pontos[1];j++){
	      x = image.at&lt;uchar&gt;(i,j);
	      image.at&lt;uchar&gt;(i,j)= 255 - x;
	    }
	  }
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>São feitos, então, 4 blocos <em>if</em> para determinar o retângulo delimitado pelos dois pontos. Foram colocados quatro blocos, para que o usuário pudesse entrar com pontos quaisquer e em qualquer ordem, sem se preocupar em precisar fornecer as coordenadas em ordem crescente.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint c++ language-c++"><code>	      x = image.at&lt;uchar&gt;(i,j);
	      image.at&lt;uchar&gt;(i,j)= 255 - x;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finalmente, para cada ponto dentro do retângulo é calculado o seu valor <em>x</em> e, em seguida, o negativo, como sendo <em>255 - x</em>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_1_2_exerc_cio_2">1.2 Exercício 2</h3>
<div class="paragraph">
<p>Implementar o programa <code>trocaregioes.cpp</code>, que embaralha aleatóriamente as regiões da imagem, como um quebra cabeça.</p>
</div>
<div class="sect3">
<h4 id="_c_digo_2">Código</h4>
<div class="sidebarblock">
<div class="content">
<div class="listingblock">
<div class="title">trocaregioes.cpp</div>
<div class="content">
<pre class="prettyprint c++ language-c++"><code>#include &lt;iostream&gt;
#include &lt;cv.h&gt;
#include &lt;highgui.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

using namespace cv;
using namespace std;

int main(int, char**){
  Mat image;
  Mat result(256, 256, CV_8U, 255);

  image= imread("biel.png",CV_LOAD_IMAGE_GRAYSCALE);
  if(!image.data)
    cout &lt;&lt; "nao abriu biel.png" &lt;&lt; endl;


  Mat roi1(image, Rect(0,0,128,128)); //(y, x, w, h)
  Mat roi2(image, Rect(128,0,128,128));
  Mat roi3(image, Rect(0,128,128,128));
  Mat roi4(image, Rect(128,128,128,128));

  /*
      |1|2|
      |3|4|
  */

  srand(time(NULL));
  int x = rand() % 24;

  if(x == 0){
    roi1.copyTo(result(Rect(0, 0, 128, 128)));
    roi2.copyTo(result(Rect(0, 128, 128, 128)));
    roi3.copyTo(result(Rect(128, 0, 128, 128)));
    roi4.copyTo(result(Rect(128, 128, 128, 128)));
  }

  if(x == 1){
    roi1.copyTo(result(Rect(0, 0, 128, 128)));
    roi2.copyTo(result(Rect(0, 128, 128, 128)));
    roi3.copyTo(result(Rect(128, 128, 128, 128)));
    roi4.copyTo(result(Rect(128, 0, 128, 128)));
  }

  if(x == 2){
    roi1.copyTo(result(Rect(0, 0, 128, 128)));
    roi2.copyTo(result(Rect(128, 0, 128, 128)));
    roi3.copyTo(result(Rect(0, 128, 128, 128)));
    roi4.copyTo(result(Rect(0, 0, 128, 128)));
  }

  if(x == 3){
    roi1.copyTo(result(Rect(0, 0, 128, 128)));
    roi2.copyTo(result(Rect(128, 0, 128, 128)));
    roi3.copyTo(result(Rect(0, 0, 128, 128)));
    roi4.copyTo(result(Rect(0, 128, 128, 128)));
  }

  if(x == 4){
    roi1.copyTo(result(Rect(0, 0, 128, 128)));
    roi2.copyTo(result(Rect(128, 128, 128, 128)));
    roi3.copyTo(result(Rect(128, 0, 128, 128)));
    roi4.copyTo(result(Rect(0, 128, 128, 128)));
  }

  if(x == 5){
    roi1.copyTo(result(Rect(0, 0, 128, 128)));
    roi2.copyTo(result(Rect(128, 128, 128, 128)));
    roi3.copyTo(result(Rect(0, 128, 128, 128)));
    roi4.copyTo(result(Rect(128, 0, 128, 128)));
  }

  if(x == 6){
    roi1.copyTo(result(Rect(128, 0, 128, 128)));
    roi2.copyTo(result(Rect(0, 0, 128, 128)));
    roi3.copyTo(result(Rect(0, 128, 128, 128)));
    roi4.copyTo(result(Rect(128, 128, 128, 128)));
  }

  if(x == 7){
    roi1.copyTo(result(Rect(128, 0, 128, 128)));
    roi2.copyTo(result(Rect(0, 0, 128, 128)));
    roi3.copyTo(result(Rect(128, 128, 128, 128)));
    roi4.copyTo(result(Rect(0, 128, 128, 128)));
  }

  if(x == 8){
    roi1.copyTo(result(Rect(128, 0, 128, 128)));
    roi2.copyTo(result(Rect(0, 128, 128, 128)));
    roi3.copyTo(result(Rect(0, 0, 128, 128)));
    roi4.copyTo(result(Rect(128, 128, 128, 128)));
  }

  if(x == 9){
    roi1.copyTo(result(Rect(128, 0, 128, 128)));
    roi2.copyTo(result(Rect(0, 128, 128, 128)));
    roi3.copyTo(result(Rect(128, 128, 128, 128)));
    roi4.copyTo(result(Rect(0, 0, 128, 128)));
  }

  if(x == 10){
    roi1.copyTo(result(Rect(128, 0, 128, 128)));
    roi2.copyTo(result(Rect(128, 128, 128, 128)));
    roi3.copyTo(result(Rect(0, 0, 128, 128)));
    roi4.copyTo(result(Rect(0, 128, 128, 128)));
  }

  if(x == 11){
    roi1.copyTo(result(Rect(128, 0, 128, 128)));
    roi2.copyTo(result(Rect(128, 128, 128, 128)));
    roi3.copyTo(result(Rect(0, 128, 128, 128)));
    roi4.copyTo(result(Rect(0, 0, 128, 128)));
  }

  if(x == 12){
    roi1.copyTo(result(Rect(0, 128, 128, 128)));
    roi2.copyTo(result(Rect(0, 0, 128, 128)));
    roi3.copyTo(result(Rect(128, 0, 128, 128)));
    roi4.copyTo(result(Rect(128, 128, 128, 128)));
  }

  if(x == 13){
    roi1.copyTo(result(Rect(0, 128, 128, 128)));
    roi2.copyTo(result(Rect(0, 0, 128, 128)));
    roi3.copyTo(result(Rect(128, 128, 128, 128)));
    roi4.copyTo(result(Rect(128, 0, 128, 128)));
  }

  if(x == 14){
    roi1.copyTo(result(Rect(0, 128, 128, 128)));
    roi2.copyTo(result(Rect(128, 0, 128, 128)));
    roi3.copyTo(result(Rect(0, 0, 128, 128)));
    roi4.copyTo(result(Rect(128, 128, 128, 128)));
  }

  if(x == 15){
    roi1.copyTo(result(Rect(0, 128, 128, 128)));
    roi2.copyTo(result(Rect(128, 0, 128, 128)));
    roi3.copyTo(result(Rect(128, 128, 128, 128)));
    roi4.copyTo(result(Rect(0, 0, 128, 128)));
  }

  if(x == 16){
    roi1.copyTo(result(Rect(0, 128, 128, 128)));
    roi2.copyTo(result(Rect(128, 128, 128, 128)));
    roi3.copyTo(result(Rect(0, 0, 128, 128)));
    roi4.copyTo(result(Rect(128, 0, 128, 128)));
  }

  if(x == 17){
    roi1.copyTo(result(Rect(0, 128, 128, 128)));
    roi2.copyTo(result(Rect(128, 128, 128, 128)));
    roi3.copyTo(result(Rect(128, 0, 128, 128)));
    roi4.copyTo(result(Rect(0, 0, 128, 128)));
  }

  if(x == 18){
    roi1.copyTo(result(Rect(128, 128, 128, 128)));
    roi2.copyTo(result(Rect(0, 0, 128, 128)));
    roi3.copyTo(result(Rect(0, 128, 128, 128)));
    roi4.copyTo(result(Rect(128, 0, 128, 128)));
  }

  if(x == 19){
    roi1.copyTo(result(Rect(128, 128, 128, 128)));
    roi2.copyTo(result(Rect(0, 0, 128, 128)));
    roi3.copyTo(result(Rect(128, 0, 128, 128)));
    roi4.copyTo(result(Rect(0, 128, 128, 128)));
  }

  if(x == 20){
    roi1.copyTo(result(Rect(128, 128, 128, 128)));
    roi2.copyTo(result(Rect(0, 128, 128, 128)));
    roi3.copyTo(result(Rect(0, 0, 128, 128)));
    roi4.copyTo(result(Rect(128, 0, 128, 128)));
  }

  if(x == 21){
    roi1.copyTo(result(Rect(128, 128, 128, 128)));
    roi2.copyTo(result(Rect(0, 128, 128, 128)));
    roi3.copyTo(result(Rect(128, 0, 128, 128)));
    roi4.copyTo(result(Rect(0, 0, 128, 128)));
  }

  if(x == 22){
    roi1.copyTo(result(Rect(128, 128, 128, 128)));
    roi2.copyTo(result(Rect(128, 0, 128, 128)));
    roi3.copyTo(result(Rect(0, 0, 128, 128)));
    roi4.copyTo(result(Rect(0, 128, 128, 128)));
  }

  if(x == 23){
    roi1.copyTo(result(Rect(128, 128, 128, 128)));
    roi2.copyTo(result(Rect(128, 0, 128, 128)));
    roi3.copyTo(result(Rect(0, 128, 128, 128)));
    roi4.copyTo(result(Rect(0, 0, 128, 128)));
  }

  imshow("janela", image);
  waitKey();
  imshow("janela", result);
  waitKey();

  return 0;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Uma das saídas do programa <code>trocaregioes.cpp</code> está na figura abaixo:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://raw.githubusercontent.com/marcellacavalcanti/PDI/master/trocaregioes_.png" alt="trocaregioes_"></span></p>
</div>
</div>
<div class="sect3">
<h4 id="_descri_o_do_c_digo_2">Descrição do código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint c++ language-c++"><code>  Mat roi1(image, Rect(0,0,128,128)); //(y, x, w, h)
  Mat roi2(image, Rect(128,0,128,128));
  Mat roi3(image, Rect(0,128,128,128));
  Mat roi4(image, Rect(128,128,128,128));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Primeiro, são criadas 4 matrizes para as quatro regiões da imagem que se quer trocar, usando a função <em>Rect</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint c++ language-c++"><code>  srand(time(NULL));
  int x = rand() % 24;

  if(x == 0){
    roi1.copyTo(result(Rect(0, 0, 128, 128)));
    roi2.copyTo(result(Rect(0, 128, 128, 128)));
    roi3.copyTo(result(Rect(128, 0, 128, 128)));
    roi4.copyTo(result(Rect(128, 128, 128, 128)));
  }

  if(x == 1){
    roi1.copyTo(result(Rect(0, 0, 128, 128)));
    roi2.copyTo(result(Rect(0, 128, 128, 128)));
    roi3.copyTo(result(Rect(128, 128, 128, 128)));
    roi4.copyTo(result(Rect(128, 0, 128, 128)));
  }

  .
  .
  .

  if(x == 23){
    roi1.copyTo(result(Rect(128, 128, 128, 128)));
    roi2.copyTo(result(Rect(128, 0, 128, 128)));
    roi3.copyTo(result(Rect(0, 128, 128, 128)));
    roi4.copyTo(result(Rect(0, 0, 128, 128)));
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Depois, são criados 24 blocos <em>if</em>, representando as 24 possibilidades de arranjo entre as quatro regiões da imagem original. Gerando um número aleatório de 0 a 23, em cada execução do programa uma combinação diferente será feita.</p>
</div>
<div class="paragraph">
<p>A colocação de cada região em outra parte da imagem é feita com as funções <em>copyTo</em> e <em>Rect</em>, e salva em outra matriz.</p>
</div>
<div class="paragraph">
<p>Essa não é a forma mais otimizada de resolver o problema, mas ainda é viável, levando em conta que são apenas 4 regiões para serem trocadas entre si.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_2_se_o_4_preenchendo_regi_es">2. Seção 4: Preenchendo regiões</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_2_1_exerc_cio_1">2.1 Exercício 1</h3>
<div class="paragraph">
<p>Propor uma solução para o problema que aconteceria no programa fornecido <code>labeling.cpp</code>, caso haja mais de 255 objetos na imagem.</p>
</div>
<div class="sect3">
<h4 id="_resolu_o">Resolução</h4>
<div class="paragraph">
<p>A quantidade de cores disponível para uma dada imagem depende da quantidade de bits usados na representação de cada cor. Com a imagem atual sendo representada em 8 bits, temos 256 tons de cinza disponíveis. Uma solução para o problema dado poderia ser aumentar a quantidade de bits para representar cada cor.</p>
</div>
<div class="paragraph">
<p>Usando 10 bits, teria-se uma disponibilidade de 1024 tons de cinza. Usando 12 bits, teria-se 4096 tons de cinza.</p>
</div>
<div class="paragraph">
<p>Outra solução para o problema também poderia ser trabalhar com a rotulação no sistema de cores RGB. Com três matrizes de cores para combinar, a quantidade diferente de rótulos também seria bem maior.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_2_2_exerc_cio_2">2.2 Exercício 2</h3>
<div class="paragraph">
<p>Aprimorar o algoritmo de contagem dado, <code>labeling.cpp</code>, para identificar objetos com buracos internos, levando em consideração que um objeto pode ter mais de um buraco. Lembrar também de não contar objetos com buracos que estejam nas bordas da imagem, pois não se pode ter certeza que realmente eles têm buracos.</p>
</div>
<div class="sect3">
<h4 id="_c_digo_3">Código</h4>
<div class="sidebarblock">
<div class="content">
<div class="listingblock">
<div class="title">labeling.cpp</div>
<div class="content">
<pre class="prettyprint c++ language-c++"><code>#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;vector&gt;

using namespace cv;
using namespace std;

int main(int argc, char** argv){
  Mat image, mask;
  int width, height;
  int nobjects, noholes;
  vector&lt;int&gt; objects;

  CvPoint p;
  image = imread("bolhas2.png",CV_LOAD_IMAGE_GRAYSCALE);

  if(!image.data){
    std::cout &lt;&lt; "imagem nao carregou corretamente\n";
    return(-1);
  }

  width=image.size().width;
  height=image.size().height;

  // procurando objetos

  p.x=0;
  p.y=0;

  nobjects=0;
  for(int i=0; i&lt;height; i++){
    for(int j=0; j&lt;width; j++){
      if(image.at&lt;uchar&gt;(i,j) == 255){
		    // achou um objeto
		    nobjects++;
		    p.x=j;
		    p.y=i;
		    floodFill(image,p,nobjects);
	    }
	  }
  }

  imshow("image", image);
  imwrite("labeling.png", image);
  waitKey();

  // retirando objetos das bordas

  for(int i=0; i&lt;height; i++){
    for(int j=0; j&lt;width; j++){
      if(i==0 | i==255 | j==0 | j==255){
        if(image.at&lt;uchar&gt;(i,j) != 0){
          p.x=j;
          p.y=i;
          floodFill(image,p,0);
        }
      }
    }
  }

  // trocando o fundo da imagem

  p.x=0;
  p.y=0;
  floodFill(image,p,255);

  // procurando objetos com buracos

  noholes=0;
  for(int i=0; i&lt;height; i++){
    for(int j=0; j&lt;width; j++){
      int flag=0;
      if(image.at&lt;uchar&gt;(i,j) == 0){ // achou um buraco

        int ant = (int) image.at&lt;uchar&gt;(i, j-1); // salva o valor do pixel anterior à semente do buraco encontrado

        for(int k=0; k&lt;objects.size(); k++){
          if(ant == objects[k]){
            flag=1;
          }
        }
        if(flag==0){
          objects.push_back(ant);
          noholes++;
        }

        // rotulando o buraco com 255
        p.x=j;
        p.y=i;
        floodFill(image,p,255);
      }
    }
  }

  cout &lt;&lt; "Ignorando os objetos localizados nas bordas da imagem, o número de objetos com um ou mais buracos é " &lt;&lt; noholes &lt;&lt; "." &lt;&lt; endl;

  return 0;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Para testar a nova funcionalidade de procurar buracos nas imagens, levando em consideração que uma bolha pode ter mais de um buraco, usou-se a imagem abaixo:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://raw.githubusercontent.com/marcellacavalcanti/PDI/master/bolhas_.png" alt="bolhas_"></span></p>
</div>
<div class="paragraph">
<p>Ao executar o programa, tem-se o retorno da quantidade de objetos com buracos e a imagem rotulada:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://raw.githubusercontent.com/marcellacavalcanti/PDI/master/labeling_exe.png" alt="labeling_exe"></span></p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://raw.githubusercontent.com/marcellacavalcanti/PDI/master/labeling_.png" alt="labeling_"></span></p>
</div>
</div>
<div class="sect3">
<h4 id="_descri_o_do_c_digo_3">Descrição do código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint c++ language-c++"><code>  // retirando objetos das bordas

  for(int i=0; i&lt;height; i++){
    for(int j=0; j&lt;width; j++){
      if(i==0 | i==255 | j==0 | j==255){
        if(image.at&lt;uchar&gt;(i,j) != 0){
          p.x=j;
          p.y=i;
          floodFill(image,p,0);
        }
      }
    }
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Após procurar e rotular os objetos, como no algoritmo dado, retirou-se os objetos das bordas, para que não sejam procurados buracos neles. Para isso, percorreu-se as bordas da imagem procurando por um tom de cinza diferente de 0. Quando o algoritmo acha a semente, aplica um <em>floodFill</em> e deixa o objeto com a mesma cor do fundo da imagem, para que ele desapareça.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint c++ language-c++"><code>  // trocando o fundo da imagem

  p.x=0;
  p.y=0;
  floodFill(image,p,255);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para que posteriormente possamos identificar buracos na imagem, trocamos a cor de fundo para <em>255</em>, aplicando o algoritmo <em>floodFill</em> com a semente no ponto (0,0).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint c++ language-c++"><code>      int flag=0;
      if(image.at&lt;uchar&gt;(i,j) == 0){ // achou um buraco

        int ant = (int) image.at&lt;uchar&gt;(i, j-1); // salva o valor do pixel anterior à semente do buraco encontrado

        for(int k=0; k&lt;objects.size(); k++){
          if(ant == objects[k]){
            flag=1;
          }
        }
        if(flag==0){
          objects.push_back(ant);
          noholes++;
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dentro dos loops para percorrer a imagem novamente, procurando pelo tom de cinza 0 (que agora representa apenas os buracos nos objetos), inicia-se outro loop. Ao achar um ponto com tom de cinza igual a 0, o programa vai pegar o tom de cinza do ponto anterior e checar se ele já se encontra em um vetor <em>objects</em> (inicialmente nulo). Caso o tom de cinza não esteja presente no vetor, coloca-se ele lá, usando a função <em>push_back</em> e incrementa-se o valor de objetos com buracos. Caso o tom de cinza do ponto anterior já esteja no vetor <em>objetcs</em>, significa que já foi encontrado um buraco naquele objeto, então o programa passa por ele e não incrementa o número de objetos com buracos.</p>
</div>
<div class="paragraph">
<p>No final, todos os buracos terminam rotulados com o novo valor do fundo da imagem, 255.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_3_se_o_6_filtragem_no_dom_nio_espacial_i">3. Seção 6: Filtragem no domínio espacial I</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_3_1_exerc_cio">3.1 Exercício</h3>
<div class="paragraph">
<p>Acrescentar mais uma função ao programa <code>filtroespacial.cpp</code>, permitindo que seja calculado o laplaciano do gaussiano das imagens capturadas.</p>
</div>
<div class="sect3">
<h4 id="_c_digo_4">Código</h4>
<div class="sidebarblock">
<div class="content">
<div class="listingblock">
<div class="title">filtroespacial.cpp</div>
<div class="content">
<pre class="prettyprint c++ language-c++"><code>#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

using namespace cv;
using namespace std;

void printmask(Mat &amp;m){
  for(int i=0; i&lt;m.size().height; i++){
    for(int j=0; j&lt;m.size().width; j++){
      cout &lt;&lt; m.at&lt;float&gt;(i,j) &lt;&lt; ",";
    }
    cout &lt;&lt; endl;
  }
}

void menu(){
  cout &lt;&lt; "\npressione a tecla para ativar o filtro: \n"
	"a - calcular modulo\n"
    "m - media\n"
    "g - gauss\n"
    "v - vertical\n"
	"h - horizontal\n"
    "l - laplaciano\n"
  "o - laplaciano do gaussiano\n"
	"esc - sair\n";
}

int main(int argvc, char** argv){
  VideoCapture video;
  float media[] = {1,1,1,
				   1,1,1,
				   1,1,1};
  float gauss[] = {1,2,1,
				   2,4,2,
				   1,2,1};
  float horizontal[]={-1,0,1,
					  -2,0,2,
					  -1,0,1};
  float vertical[]={-1,-2,-1,
					0,0,0,
					1,2,1};
  float laplacian[]={0,-1,0,
					 -1,4,-1,
					 0,-1,0};
  float lapgauss[]={0,0,1,0,0,
                    0,1,2,1,0,
                    1,2,-16,2,1,
                    0,1,2,1,0,
                    0,0,1,0,0};

  Mat cap, frame, frame32f, frameFiltered;
  Mat mask, mask1;
  Mat result, result1;
  double width, height, min, max;
  int absolut;
  char key;

  video.open(0);
  if(!video.isOpened())
    return -1;
  width=video.get(CV_CAP_PROP_FRAME_WIDTH);
  height=video.get(CV_CAP_PROP_FRAME_HEIGHT);
  std::cout &lt;&lt; "largura=" &lt;&lt; width &lt;&lt; "\n";;
  std::cout &lt;&lt; "altura =" &lt;&lt; height&lt;&lt; "\n";;

  namedWindow("filtroespacial",1);

  mask = Mat(3, 3, CV_32F, media);
  scaleAdd(mask, 1/9.0, Mat::zeros(3,3,CV_32F), mask1);
  swap(mask, mask1);
  absolut=1; // calcs abs of the image

  menu();
  for(;;){
    video &gt;&gt; cap;
    cvtColor(cap, frame, CV_BGR2GRAY);
    flip(frame, frame, 1);
    imshow("original", frame);
    frame.convertTo(frame32f, CV_32F);
    filter2D(frame32f, frameFiltered, frame32f.depth(), mask, Point(1,1), 0);
    if(absolut){
      frameFiltered=abs(frameFiltered);
    }
    frameFiltered.convertTo(result, CV_8U);
    imshow("filtroespacial", result);
    key = (char) waitKey(10);
    if( key == 27 ) break; // esc pressed!
    switch(key){
    case 'a':
	  menu();
      absolut=!absolut;
      break;
    case 'm':
	  menu();
      mask = Mat(3, 3, CV_32F, media);
      scaleAdd(mask, 1/9.0, Mat::zeros(3,3,CV_32F), mask1);
      mask = mask1;
      printmask(mask);
      break;
    case 'g':
	  menu();
      mask = Mat(3, 3, CV_32F, gauss);
      scaleAdd(mask, 1/16.0, Mat::zeros(3,3,CV_32F), mask1);
      mask = mask1;
      printmask(mask);
      break;
    case 'h':
	  menu();
      mask = Mat(3, 3, CV_32F, horizontal);
      printmask(mask);
      break;
    case 'v':
	  menu();
      mask = Mat(3, 3, CV_32F, vertical);
      printmask(mask);
      break;
    case 'l':
	  menu();
      mask = Mat(3, 3, CV_32F, laplacian);
      printmask(mask);
      break;
    case 'o':
    menu();
      mask = Mat(5, 5, CV_32F, lapgauss);
      printmask(mask);
      break;
    default:
      break;
    }
  }
  return 0;
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>A saída do programa, quando escolhida a opção <em>"o"</em>, referida ao filtro laplaciano do gaussiano, está representada na imagem abaixo:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://raw.githubusercontent.com/marcellacavalcanti/PDI/master/filtroespacial_.png" alt="filtroespacial_"></span></p>
</div>
<div class="paragraph">
<p>Colocando lado a lado as saídas do filtro <em>laplaciano</em> e <em>laplaciano do gaussiano</em>, respectivamente, podemos observar que o segundo possui mais nitidez nos contornos, mas também mais ruído.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://raw.githubusercontent.com/marcellacavalcanti/PDI/master/laplaciano_.png" alt="500" width="397"></span> <span class="image"><img src="https://raw.githubusercontent.com/marcellacavalcanti/PDI/master/lapgauss_.png" alt="500" width="397"></span></p>
</div>
</div>
<div class="sect3">
<h4 id="_descri_o_do_c_digo_4">Descrição do código</h4>
<div class="paragraph">
<p>Pesquisando sobre o filtro Laplaciano do Gaussiano, achei, <a href="http://fourier.eng.hmc.edu/e161/lectures/gradient/node8.html">nesse site</a>, uma máscara 5x5 associada ao filtro.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint c++ language-c++"><code>  float lapgauss[]={0,0,1,0,0,
                    0,1,2,1,0,
                    1,2,-16,2,1,
                    0,1,2,1,0,
                    0,0,1,0,0};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Após isso, apenas adicionei a máscara <em>lapgauss</em> às outras já implementadas no algoritmo original e adicionei mais um <em>case</em>, para que o caractere <em>"o"</em> fosse o correspondente ao filtro laplaciano do gaussiano.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint c++ language-c++"><code>    case 'o':
    menu();
      mask = Mat(5, 5, CV_32F, lapgauss);
      printmask(mask);
      break;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_4_se_o_7_filtragem_no_dom_nio_espacial_ii">4. Seção 7: Filtragem no domínio espacial II</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_4_1_exerc_cio_1">4.1 Exercício 1</h3>
<div class="paragraph">
<p>Implementar um programa <code>tiltshift.cpp</code> com três ajustes presentes na interface:
- um ajuste para regular a altura da região central que entrará em foco;
- um ajuste para regular a força de decaimento da região borrada;
- um ajuste para regular a posição vertical do centro da região que entrará em foco.</p>
</div>
<div class="sect3">
<h4 id="_c_digo_5">Código</h4>
<div class="sidebarblock">
<div class="content">
<div class="listingblock">
<div class="title">tiltshift.cpp</div>
<div class="content">
<pre class="prettyprint c++ language-c++"><code>#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;math.h&gt;

using namespace cv;
using namespace std;

int getAlpha (int x, int l1, int l2, int d){
	double alpha = (float)255*(float)1/(float)2*((float)tanh(((float)x-(float)l1)/(float)d)-(float)tanh(((float)x-(float)l2)/(float)d));
  int var = static_cast&lt;int&gt;(alpha);

	return alpha;
}

int main(int, char**){
  Mat imagem;
  Mat imagemblur;

  Mat teste;

	Mat image(256,256, CV_8U, 255);
	Mat imageneg(256,256, CV_8U, 255);
	int width, height;

  Mat resultadopos(256,256, CV_16U);
  Mat resultadoneg(256,256, CV_16U);

  Mat blended;

  imagem= imread("tiltshift.png",CV_LOAD_IMAGE_COLOR);
  if(!imagem.data)
    cout &lt;&lt; "nao abriu tilfshit.png" &lt;&lt; endl;
  imagemblur= imread("tiltshiftblur.png",CV_LOAD_IMAGE_COLOR);
  if(!imagem.data)
    cout &lt;&lt; "nao abriu tilfshitblur.png" &lt;&lt; endl;

  float l1 = 100;
  float l2 = 150;
  float d = 10;

  width=image.size().width;
  height=image.size().height;

  for(int i = 0; i &lt; width; i++){
    for(int j = 0; j&lt;height; j++){
      image.at&lt;uchar&gt;(i, j) = getAlpha(i, l1, l2, d);
    }
  }

  for(int i=0; i&lt;width; i++){
  	for(int j=0; j&lt;height; j++){
  		imageneg.at&lt;uchar&gt;(i,j) = 255 - image.at&lt;uchar&gt;(i,j);
  	}
  }

  cvtColor(image, image, CV_GRAY2RGB);
  cvtColor(imageneg, imageneg, CV_GRAY2RGB);

  multiply(imagem, image, resultadopos, 1.0, CV_16U);
  multiply(imagemblur, imageneg, resultadoneg, 1.0, CV_16U);

  addWeighted(resultadopos, 0.5, resultadoneg, 0.5, 100.0, blended);
  imwrite("tiltshit_res.png", blended);

  /*
  imshow("janela", resultadopos);
  waitKey();
  imshow("janela", resultadoneg);
  waitKey();
  */

  imwrite("tiltshift_result.png", blended);

  imshow("janela", blended);
  waitKey();
	return 0;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As imagens (original e já borrada, as duas com alteração no contraste) usadas para a execução do programa, com <em>l<sub>1</sub></em>=100, <em>l<sub>2</sub></em>=150 e <em>d</em>=10 foram:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://raw.githubusercontent.com/marcellacavalcanti/PDI/master/tiltshiftori_.png" alt="tiltshiftori_"></span> <span class="image"><img src="https://raw.githubusercontent.com/marcellacavalcanti/PDI/master/tiltshiftblur_.png" alt="tiltshiftblur_"></span></p>
</div>
<div class="paragraph">
<p>As imagens obtidas da equação de ponderação, para as mesmas condições, foram:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://raw.githubusercontent.com/marcellacavalcanti/PDI/master/pond_.png" alt="pond_"></span> <span class="image"><img src="https://raw.githubusercontent.com/marcellacavalcanti/PDI/master/pondneg_.png" alt="pondneg_"></span></p>
</div>
<div class="paragraph">
<p>O resultado final foi:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://raw.githubusercontent.com/marcellacavalcanti/PDI/master/tiltshift_res.png" alt="tiltshift_res"></span></p>
</div>
</div>
<div class="sect3">
<h4 id="_descri_o_do_c_digo_5">Descrição do código</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint c++ language-c++"><code>int getAlpha (int x, int l1, int l2, int d){
	double alpha = (float)255*(float)1/(float)2*((float)tanh(((float)x-(float)l1)/(float)d)-(float)tanh(((float)x-(float)l2)/(float)d));
  int var = static_cast&lt;int&gt;(alpha);

	return alpha;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Primeiro, implementou-se a função de ponderação dada no tutorial, observando a necessidade de se fazer um casting de int para float, para que as imagens de ponderação fiquem corretas.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint c++ language-c++"><code>  imagem= imread("tiltshift.png",CV_LOAD_IMAGE_COLOR);
  if(!imagem.data)
    cout &lt;&lt; "nao abriu tilfshit.png" &lt;&lt; endl;
  imagemblur= imread("tiltshiftblur.png",CV_LOAD_IMAGE_COLOR);
  if(!imagem.data)
    cout &lt;&lt; "nao abriu tilfshitblur.png" &lt;&lt; endl;


	float l1 = 100;
	float l2 = 150;
	float d = 10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Entram no programa já as duas imagens para a implementação do tiltshift: uma normal e a outra borrada, as duas com alteração em brilho e contraste. Os valores para <em>l<sub>1</sub></em>, <em>l<sub>2</sub></em> e <em>d</em> são modificados dentro do código.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint c++ language-c++"><code>  for(int i = 0; i &lt; width; i++){
    for(int j = 0; j&lt;height; j++){
      image.at&lt;uchar&gt;(i, j) = getAlpha(i, l1, l2, d);
    }
  }

  for(int i=0; i&lt;width; i++){
  	for(int j=0; j&lt;height; j++){
  		imageneg.at&lt;uchar&gt;(i,j) = 255 - image.at&lt;uchar&gt;(i,j);
  	}
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Percorrendo duas matrizes já determinadas, pega-se cada valor de <em>i</em>, junto aos valores de <em>l<sub>1</sub></em>, <em>l<sub>2</sub></em> e <em>d</em>, e manda-os para a função <em>getAlpha</em>, que vai retornar o valor da ponderação, de acordo com a equação fornecida, para cada linha da imagem. A segunda imagem a calculada como o negativo da primeira.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint c++ language-c++"><code>  cvtColor(image, image, CV_GRAY2RGB);
  cvtColor(imageneg, imageneg, CV_GRAY2RGB);

  multiply(imagem, image, resultadopos, 1.0, CV_16U);
  multiply(imagemblur, imageneg, resultadoneg, 1.0, CV_16U);

  addWeighted(resultadopos, 0.5, resultadoneg, 0.5, 100.0, blended);
  imwrite("tiltshit_res.png", blended);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Converte-se cada imagem de ponderação para o espaço <em>RGB</em> e usa-se a função <em>multiply</em> para ponderar as imagens normal e borrada - a normal pela imagem ponderada e a borrada pelo seu negativo. Após isso, usa-se a função <em>addWeighted</em> para combinar os resultados das imagens vindas dos <em>multiply</em>, ambas com peso 0.5.</p>
</div>
<div class="paragraph">
<p>Ao final, a imagem é salva como <em>tiltshift_result.png</em>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_5_se_o_8_filtragem_no_dom_nio_da_frequ_ncia">5. Seção 8: Filtragem no domínio da frequência</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_5_1_exerc_cio">5.1 Exercício</h3>
<div class="paragraph">
<p>A partir do algoritmo da seção no tutorial da disciplina, implementar o filtro homomórfico para regular imagens mal iluminadas.</p>
</div>
<div class="sect3">
<h4 id="_c_digo_6">Código</h4>
<div class="sidebarblock">
<div class="content">
<div class="listingblock">
<div class="title">filtrohomomorfico.cpp</div>
<div class="content">
<pre class="prettyprint c++ language-c++"><code>#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;opencv2/imgproc/imgproc.hpp&gt;

using namespace cv;
using namespace std;

// troca os quadrantes da imagem da DFT
void deslocaDFT(Mat&amp; image ){
  Mat tmp, A, B, C, D;

  // se a imagem tiver tamanho impar, recorta a regiao para
  // evitar cópias de tamanho desigual
  image = image(Rect(0, 0, image.cols &amp; -2, image.rows &amp; -2));
  int cx = image.cols/2;
  int cy = image.rows/2;

  // reorganiza os quadrantes da transformada
  // A B   -&gt;  D C
  // C D       B A
  A = image(Rect(0, 0, cx, cy));
  B = image(Rect(cx, 0, cx, cy));
  C = image(Rect(0, cy, cx, cy));
  D = image(Rect(cx, cy, cx, cy));

  // A &lt;-&gt; D
  A.copyTo(tmp);  D.copyTo(A);  tmp.copyTo(D);

  // C &lt;-&gt; B
  C.copyTo(tmp);  B.copyTo(C);  tmp.copyTo(B);
}

int main(int , char**){
  Mat imaginaryInput, complexImage, multsp;
  Mat padded, filter, mag;
  Mat image, imagegray, tmp;
  Mat_&lt;float&gt; realInput, zeros;
  vector&lt;Mat&gt; planos;

  // guarda tecla capturada
  char key;

  image = imread("imagem1.png",CV_LOAD_IMAGE_GRAYSCALE);

  // valores ideais dos tamanhos da imagem
  // para calculo da DFT
  int dft_M, dft_N;

  // captura uma imagem para recuperar as
  // informacoes de gravação


  // identifica os tamanhos otimos para
  // calculo do FFT
  dft_M = getOptimalDFTSize(image.rows);
  dft_N = getOptimalDFTSize(image.cols);

  // realiza o padding da imagem
  copyMakeBorder(image, padded, 0,
                 dft_M - image.rows, 0,
                 dft_N - image.cols,
                 BORDER_CONSTANT, Scalar::all(0));

  // parte imaginaria da matriz complexa (preenchida com zeros)
  zeros = Mat_&lt;float&gt;::zeros(padded.size());

  // prepara a matriz complexa para ser preenchida
  complexImage = Mat(padded.size(), CV_32FC2, Scalar(0));

  // a função de transferência (filtro frequencial) deve ter o
  // mesmo tamanho e tipo da matriz complexa
  filter = complexImage.clone();

  // cria uma matriz temporária para criar as componentes real
  // e imaginaria do filtro ideal
  tmp = Mat(dft_M, dft_N, CV_32F);

  float gh, gl, c, d0;

  cout &lt;&lt; "Escolha os parâmetros gh, gl, c e D0 para o filtro homomórfico:" &lt;&lt; endl &lt;&lt; "gh = ";
  cin &gt;&gt; gh;
  cout &lt;&lt; "gl = ";
  cin &gt;&gt; gl;
  cout &lt;&lt; "c = ";
  cin &gt;&gt; c;
  cout &lt;&lt; "D0 = ";
  cin &gt;&gt; d0;

  int M=dft_M;
  int N=dft_N;

  // prepara o filtro passa-baixas ideal
  for(int i=0; i&lt;dft_M; i++){
    for(int j=0; j&lt;dft_N; j++){
        tmp.at&lt;float&gt; (i,j) = (gh-gl)*(1.0-exp(-1.0*(float)c*((((float)i-M/2.0)*((float)i-M/2.0) + ((float)j-N/2.0)*((float)j-N/2.0))/(d0*d0))))+ gl;
    }
  }

  // cria a matriz com as componentes do filtro e junta
  // ambas em uma matriz multicanal complexa
  Mat comps[]= {tmp, tmp};
  merge(comps, 2, filter);

  for(;;){

    //exp(complexImage, complexImage);

    // limpa o array de matrizes que vao compor a
    // imagem complexa
    planos.clear();
    // cria a compoente real
    realInput = Mat_&lt;float&gt;(padded);
    // insere as duas componentes no array de matrizes
    planos.push_back(realInput);
    planos.push_back(zeros);

    // combina o array de matrizes em uma unica
    // componente complexa
    merge(planos, complexImage);

    //add(complexImage, 1, complexImage);

    //exp(complexImage, complexImage);

    // calcula o dft
    dft(complexImage, complexImage);

    // realiza a troca de quadrantes
    deslocaDFT(complexImage);

    // aplica o filtro frequencial
    mulSpectrums(complexImage,filter,complexImage,0);

    // limpa o array de planos
    planos.clear();
    // separa as partes real e imaginaria para modifica-las
    split(complexImage, planos);

    // recompoe os planos em uma unica matriz complexa
    merge(planos, complexImage);

    // troca novamente os quadrantes
    deslocaDFT(complexImage);

    // calcula a DFT inversa
    idft(complexImage, complexImage);

    //log(complexImage, complexImage);

    // limpa o array de planos
    planos.clear();

    // separa as partes real e imaginaria da
    // imagem filtrada
    split(complexImage, planos);

    // normaliza a parte real para exibicao
    normalize(planos[0], planos[0], 0, 1, CV_MINMAX);

    imshow("original", image);
    imshow("filtrada", planos[0]);

    key = (char) waitKey(10);
    if( key == 27 ) break; // esc pressed!
  }
  return 0;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_descri_o_do_c_digo_6">Descrição do código</h4>

</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_6_se_o_10_canny_e_a_arte_com_pontilhismo">6. Seção 10: Canny e a arte com pontilhismo</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_6_1_exerc_cio">6.1 Exercício</h3>
<div class="paragraph">
<p>Utilizar como referências os algoritmos sobre Canny e pontilhismo dados no tutorial da disciplina para, utilizando as bordas de Canny, aprimorar a qualidade da imagem pontilhista.</p>
</div>
<div class="sect3">
<h4 id="_c_digo_7">Código</h4>
<div class="sidebarblock">
<div class="content">
<div class="listingblock">
<div class="title">cannypoints.cpp</div>
<div class="content">
<pre class="prettyprint c++ language-c++"><code>#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;fstream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;ctime&gt;
#include &lt;cstdlib&gt;

using namespace std;
using namespace cv;

#define STEP 10
#define JITTER 5
#define RAIO 5

int main(int argc, char** argv){
  vector&lt;int&gt; yrange;
  vector&lt;int&gt; xrange;

  Mat image, frame, points, border;

  int width, height, gray;
  int x, y;

  Vec3b val;

  image= imread(argv[1],CV_LOAD_IMAGE_COLOR);

  srand(time(0));

  if(!image.data){
  cout &lt;&lt; "nao abriu" &lt;&lt; argv[1] &lt;&lt; endl;
    cout &lt;&lt; argv[0] &lt;&lt; " imagem.jpg";
    exit(0);
  }

  width=image.size().width;
  height=image.size().height;

  xrange.resize(height/STEP);
  yrange.resize(width/STEP);

  iota(xrange.begin(), xrange.end(), 0);
  iota(yrange.begin(), yrange.end(), 0);

  for(uint i=0; i&lt;xrange.size(); i++){
    xrange[i]= xrange[i]*STEP+STEP/2;
    yrange[i]= yrange[i]*STEP+STEP/2;
  }

  points = Mat(height, width, CV_8UC3, Scalar(255, 255, 255));

  random_shuffle(xrange.begin(), xrange.end());

  for(auto i : xrange){
    random_shuffle(yrange.begin(), yrange.end());
    for(auto j : yrange){
      x = i+rand()%(2*JITTER)-JITTER+1;
      y = j+rand()%(2*JITTER)-JITTER+1;
      val = image.at&lt;Vec3b&gt;(x,y);
      circle(points,
             cv::Point(y,x),
             RAIO,
             CV_RGB(val[2],val[1],val[0]),
             -1,
             CV_AA);
    }
  }

  imshow("pontilhismo", points);
  waitKey();

  int l = 20;
  int r = 1;

  for(int a=0; a&lt;10; a++){
    Canny(image, border, l, 3*l);
    l=l*10;
    for(int i=1; i&lt;width; i++){
      for(int j=1; j&lt;height; j++){
        if(border.at&lt;uchar&gt;(i,j) == 255){
          val = image.at&lt;Vec3b&gt;(i,j);
          circle(points,
                 cv::Point(j,i),
                 r,
                 CV_RGB(val[2],val[1],val[0]),
                 -1,
                 CV_AA);
        }
      }
    }
    r=r+1;
  }

  imwrite("cannypoints.jpg", points);
  return 0;
}
</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_descri_o_do_c_digo_7">Descrição do código</h4>

</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_bibliografia">Bibliografia</h2>
<div class="sectionbody">
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><em>OpenCV 2.4.12.0 documentation</em>. Disponível em <a href="http://docs.opencv.org/2.4/index.html">http://docs.opencv.org/2.4/index.html</a>. Acesso em 21 de Março de 2016.</p>
</li>
<li>
<p><em>Laplacian of Gaussian (LoG)</em>. Disponível em <a href="http://fourier.eng.hmc.edu/e161/lectures/gradient/node8.html">http://fourier.eng.hmc.edu/e161/lectures/gradient/node8.html</a>. Acesso em 21 de Março de 2016.</p>
</li>
<li>
<p><em>Asciidoctor User Manual</em>. Disponível em <a href="http://asciidoctor.org/docs/user-manual">http://asciidoctor.org/docs/user-manual</a>. Acesso em 21 de Março de 2016.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2016-05-10 23:34:30 BRT
</div>
</div>
</body>
</html>